
<h3 align="center">🧠 x86 Assembly Crash Course — TryHackMe Malware Analysis Room</h3>

<p align="center">
  <b>Complete Guide to Learning Assembly for Malware Reverse Engineering</b><br>
  <i>Full task content, enhanced formatting, and no content removed.</i>
</p>

<p align="center">
  <img src="https://img.shields.io/badge/topic-x86%20Assembly-blueviolet?style=flat-square">
  <img src="https://img.shields.io/badge/focus-Malware%20RE-red?style=flat-square">
  <img src="https://img.shields.io/badge/source-TryHackMe-green?style=flat-square">
  <img src="https://img.shields.io/badge/status-Full_Content_Retained-black?style=flat-square">
</p>

## 🧭 Navigation

- [🧩 Task 1: Introduction](#-task-1-introduction)
- [🔢 Task 2: Opcodes and Operands](#-task-2-opcodes-and-operands)
- [🧾 Task 3: General Instructions](#-task-3-general-instructions)
- [🎯 Task 4: Flags](#-task-4-flags)
- [➕ Task 5: Arithmetic and Logical Instructions](#-task-5-arithmetic-and-logical-instructions)
- [🔁 Task 6: Conditionals and Branching](#-task-6-conditionals-and-branching)
- [🗂️ Task 7: Stack and Function Calls](#-task-7-stack-and-function-calls)
- [🧪 Task 8: Practice Time](#-task-8-practice-time)

---

<h2 align="center">TryHackMe — Malware Analysis Module /Room2-x86 Assembly Crash Course</h2>

## 1. Introduction

Assembly is the most reliable form of decompiled binary. You'll learn how to interpret low-level code for malware analysis.  
Recommended: Complete the **x86 Architecture Overview** before this.

---

## 2. Opcodes & Operands

- **Opcodes** are binary hex codes that represent instructions.
- **Operands** specify values or addresses that opcodes operate on.

### 🧪 Code Example:
```asm
mov eax, 0x5f
```

Disassembled:
```
040000: b8 5f 00 00 00  => mov eax, 0x5f
```

### 🔎 Questions:
**Q1**: What are the hex codes that denote the assembly operations called?  
<details><summary>Answer</summary>Opcodes</details>

**Q2**: Which operand type uses square brackets?  
<details><summary>Answer</summary>Memory operand</details>

---

## 3. General Instructions

Instructions like `mov`, `lea`, `nop`, `shr`, and `shl`.

### 🧪 MOV vs LEA
```asm
mov eax, [ebp+4]  ; Load VALUE from address
lea eax, [ebp+4]  ; Load ADDRESS
```

### 🧪 NOP Sled
```asm
nop ; Used to align shellcode
```

### 🔎 Questions:
**Q1**: In `mov eax, ebx`, which is the destination?  
<details><summary>Answer</summary>eax</details>

**Q2**: What instruction performs no action?  
<details><summary>Answer</summary>nop</details>

---

## 4. Flags

- **ZF (Zero Flag)** – Set if result is 0  
- **SF (Sign Flag)** – Set if result is negative

### 🔎 Questions:
**Q1**: Which flag is set if the result is zero?  
<details><summary>Answer</summary>ZF</details>

**Q2**: Which flag is set if the result is negative?  
<details><summary>Answer</summary>SF</details>

---

## 5. Arithmetic & Logical Instructions

- `add`, `sub`, `mul`, `div`, `inc`, `dec`
- `and`, `or`, `not`, `xor`

### 🧪 XOR Trick
```asm
xor eax, eax  ; Zeroes eax efficiently
```

### 🔎 Questions:
**Q1**: Which flag is set if the destination is smaller during subtraction?  
<details><summary>Answer</summary>Carry Flag</details>

**Q2**: Which instruction increases a register?  
<details><summary>Answer</summary>inc</details>

**Q3**: Do the following do the same?
```asm
xor eax, eax
mov eax, 0
```
<details><summary>Answer</summary>yea</details>

---

## 6. Conditionals & Branching

- `cmp` → compares
- `test` → AND but only sets flags
- `jmp`, `jz`, `jnz`, `jc`, `jnc` → conditional jumps

### 🔎 Questions:
**Q1**: Which flag is set when `test` result is 0?  
<details><summary>Answer</summary>Zero flag</details>

**Q2**: Which op compares via subtraction?  
<details><summary>Answer</summary>1 (cmp)</details>

**Q3**: Which flag is used for `jz`/`jnz`?  
<details><summary>Answer</summary>Zero Flag</details>

---

## 7. Stack & Function Calls

- **PUSH**: `push eax`
- **POP**: `pop eax`
- **CALL**: `call 0x1234`
- **pusha/pushad** → Push all registers

### 🔎 Questions:
**Q1**: Which instruction is used for function calls?  
<details><summary>Answer</summary>call</details>

**Q2**: Which pushes all registers to stack?  
<details><summary>Answer</summary>pusha</details>

---

## 8. Practice Time 🧪

Use the emulator (e.g., [x86emu](https://x86emu.org/) or local debugger) to run the following.

### 🧮 MOV Example
```asm
mov eax,10h
mov ebx,32h
mov ecx,eax
mov [eax],40h
add [eax],30h
mov [ebx],[eax]   ; Expect memory-to-memory error
```

### 🔎 Questions:
**Q1**: What is `[eax]` after the 4th instruction?  
<details><summary>Answer</summary>0x00000040</details>

**Q2**: What error appears after `mov [ebx],[eax]`?  
<details><summary>Answer</summary>Memory to memory data movement is not allowed.</details>

---

### 🧮 Stack Example
```asm
push eax
push ebx
push ecx
push edx
pop eax
pop ebx
pop ecx
pop edx
```

### 🔎 Questions:
**Q3**: Value of eax after 9th instruction?  
<details><summary>Answer</summary>0x00000025</details>

**Q4**: Value of edx after 12th instruction?  
<details><summary>Answer</summary>0x00000010</details>

**Q5**: Top of stack after `pop ecx`?  
<details><summary>Answer</summary>0x00000010</details>

---

### 🧮 CMP & TEST
```asm
cmp eax, ebx
test eax, ebx
```

### 🔎 Questions:
**Q6**: Flags triggered after `cmp eax, ebx` (equal)?  
<details><summary>Answer</summary>PF,ZF</details>

**Q7**: Flags triggered when `eax < ebx`?  
<details><summary>Answer</summary>CF,SF</details>

---

### 🧮 LEA Example
```asm
lea eax, [ebx+ecx]
```

### 🔎 Questions:
**Q8**: Value of eax after LEA?  
<details><summary>Answer</summary>0x0000004B</details>

**Q9**: Final value of ECX after LEA block?  
<details><summary>Answer</summary>0x00000045</details>

---

<p align="center">
  <i>“Understand Assembly to Read Between the Binaries.”</i>
</p>
